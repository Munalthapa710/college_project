{% extends 'user_base.html' %}
 {% block head_extra %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
   <style>
        /* --- Temporary Chat Box Styles --- */
        .chat-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 320px;
            max-width: 90vw;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none; /* Initially hidden */
            flex-direction: column;
            z-index: 1010;
        }
        .chat-header {
            background-color: #343a40; /* Driver navbar color */
            color: white;
            padding: 10px 15px;
            border-top-left-radius: 7px;
            border-top-right-radius: 7px;
            font-weight: bold;
            cursor: pointer; 
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .chat-toggle-btn
         {
           background: none;
             border: none;
               color: white;
                 font-size: 1.5em;
                  font-weight: bold;
                    line-height: 1;
                      padding: 0 5px;
                        cursor: pointer;
}
        .chat-messages {
            list-style: none;
            padding: 10px;
            margin: 0;
            height: 250px;
            overflow-y: auto;
            border-bottom: 1px solid #eee;
        }
        .chat-messages li {
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 15px;
            max-width: 80%;
            word-wrap: break-word;
        }
        .chat-messages li.sent {
            background-color: #007bff;
            color: white;
            align-self: flex-end;
            margin-left: auto; /* Push to the right */
        }
        .chat-messages li.received {
            background-color: #e9ecef;
            color: #333;
            align-self: flex-start;
        }
        .chat-input-form {
            display: flex;
            padding: 10px;
        }
        .chat-input-form input {
            flex-grow: 1;
            border: 1px solid #ccc;
            padding: 8px;
            border-radius: 20px;
            margin-right: 8px;
        }
        .chat-input-form button {
            border-radius: 50%;
            width: 40px;
            height: 40px;
            padding: 0;
            line-height: 40px;
        }
        .chat-container.minimized .chat-messages,
.chat-container.minimized .chat-input-form {
    display: none;
}

.chat-container.minimized .chat-toggle-btn::before {
     content: '○'; /* An open circle for "open me" */
    font-size: 1.2em; 
    line-height: 1;
}
.chat-container:not(.minimized) .chat-toggle-btn::before {
    content: '−'; /* A proper minus sign for "minimize me" */
    font-size: 1.5em; 
    line-height: 1;
}
    </style>
{% endblock %} {% block content %}
<h2>Welcome, {{ user.name }}</h2>
<p>
    Your current location:
    <strong>
        <span id="currentUserPreciseLocation">
            {% if user.latitude and user.longitude %} ({{ user.latitude|round(6) }}, {{ user.longitude|round(6) }}) {% else %} Please click map to set {% endif %}
        </span>
    </strong>
    <small id="userClosestNodeSubDisplay" style="display: none; color: #555; min-height: 1em;"></small>
    <span id="locationSetMessage" style="color: green; margin-left: 10px; font-weight: bold;"></span>
</p>

<div class="map-wrapper-fullwidth">
    <div class="map-container-inner">
        <div id="map"><p style="text-align: center; padding-top: 50px; color: #555;" id="mapLoadingText">Loading map...</p></div>
    </div>
</div>

<div style="text-align: center; margin-bottom: 15px; margin-top: 20px;">
    <label for="vehicleTypeSelect" style="margin-right: 10px; font-weight: 500;">Select Vehicle Type:</label>
    <select id="vehicleTypeSelect" class="role-select" style="padding: 8px 12px; border-radius: 5px; min-width: 200px; border: 1px solid #ced4da;">
        <option value="">Any Available Vehicle</option>
        {% if vehicle_types %} {% for v_type in vehicle_types %}
        <option value="{{ v_type }}">{{ v_type }}</option>
        {% endfor %} {% else %}
        <option value="Ambulance">Ambulance (Default)</option>
        <option value="Fire Truck">Fire Truck (Default)</option>
        <option value="Police Car">Police Car (Default)</option>
        {% endif %}
    </select>
</div>

<div style="text-align: center; margin-bottom: 20px;">
    <button id="findNearestBtn" onclick="findNearestAndShowPreview(true)" {% if user.latitude is none or user.longitude is none %} disabled title="Click map to set your location first." {% endif %}>
        Find Nearest Driver (Network Path)
    </button>
    <div id="nearestDriverInfo" class="info-box" style="display: none; max-width: 500px; margin-left: auto; margin-right: auto;"></div>
</div>

<div id="notifications" class="status-notifications">
    <h4>Current Ride Status:</h4>
    {% if current_ride_status %}
    <p class="status-{{ current_ride_status.type }}">
        {{ current_ride_status.message }} {% if current_ride_status.timestamp %}
        <span style="font-size: 0.9em; color: #555;">(As of: {{ current_ride_status.timestamp }})</span>
        {% endif %}
    </p>
    {% if current_ride_status.type == 'rejected' or current_ride_status.type == 'superseded' %}
    <button onclick="findNearestAndShowPreview(false)" class="btn-secondary" style="margin-top: 10px;" {% if user.latitude is none or user.longitude is none %}disabled title="Set your location on map first" {% endif %}>
        Find Another Driver
    </button>
    {% endif %} {% else %}
    <p>No active ride requests. Click "Find Nearest Driver" to start.</p>
    {% endif %}
</div>
<!-- ===== NEW CHAT BOX HTML ===== -->
    <div id="temporaryChatBox" class="chat-container">
        <div class="chat-header" onclick="toggleChatWindow()">
    <span>Chat with Driver</span>
    <button class="chat-toggle-btn"></button>
</div>
        <ul id="chatMessages" class="chat-messages">
            <!-- Messages will be added here by JavaScript -->
        </ul>
        <form id="chatForm" class="chat-input-form" onsubmit="sendChatMessage(event)">
            <input type="text" id="chatInput" placeholder="Type a message..." autocomplete="off" required>
            <button type="submit" class="btn-confirm"><i class="fas fa-paper-plane"></i></button>
        </form>
    </div>
    <!-- ===== END CHAT BOX HTML ===== -->

<script>
    let map; // Declared globally
    let userLiveMarker = null;
    let allDriverMapMarkers = {};
    let mainAcceptedRouteControl = null;
    let previewDijkstraPathLayer = null;
    let currentNearestDriverForConfirmation = null;
    let socket;
    let poiRouteControl = null;
    let activePoiMarker = null;
    let serviceMarkersLayer = L.layerGroup();
    let activeRideForChat = null;
    let excludedDriverEmails = []; 

    let currentUserLatitude = {{ user.latitude|tojson if user.latitude is not none else 'null' }};
    let currentUserLongitude = {{ user.longitude|tojson if user.longitude is not none else 'null' }};
    let userClosestNodeKeyForDijkstra = null;

    console.log("[USER DASH] Script Top: Initial Data from Flask BEGIN");
    const coordsDataForDrivers = JSON.parse('{{ coords | tojson | safe if coords is not none else "{}" | e }}');
    console.log("coordsDataForDrivers (type:", typeof coordsDataForDrivers, "):", JSON.parse(JSON.stringify(coordsDataForDrivers)));

    const graphDataForDijkstra = JSON.parse('{{ graph_for_js | tojson | safe if graph_for_js is not none else "{}" | e }}');
    console.log("graphDataForDijkstra (type:", typeof graphDataForDijkstra, "):", JSON.parse(JSON.stringify(graphDataForDijkstra)));

    const allDriversDataForFinding = JSON.parse('{{ drivers_for_js | tojson | safe if drivers_for_js is not none else "[]" | e }}');
    console.log("allDriversDataForFinding (type:", typeof allDriversDataForFinding, "):", JSON.parse(JSON.stringify(allDriversDataForFinding)));

    const currentRideStatusFromServer = JSON.parse('{{ current_ride_status | tojson | safe if current_ride_status is not none else "null" | e }}');
    console.log("currentRideStatusFromServer (type:", typeof currentRideStatusFromServer, "):", JSON.parse(JSON.stringify(currentRideStatusFromServer)));
    console.log("[USER DASH] Script Top: Initial Data from Flask END");

    const fallbackLatLng = L.latLng(27.7172, 85.3240);

    const userIcon = new L.Icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png', shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png', iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41] });
    const genericDriverIcon = new L.Icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png', shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png', iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41] });
    const enRouteDriverIcon = new L.Icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png', shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png', iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41] });
    const previewDriverIcon = new L.Icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-violet.png', shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png', iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41] });
const hospitalIcon = new L.Icon({
        iconUrl: "{{ url_for('static', filename='images/hospital-icon.png') }}",
        iconSize: [35, 35], iconAnchor: [17, 35], popupAnchor: [0, -35]
    });
    const policeIcon = new L.Icon({
        iconUrl: "{{ url_for('static', filename='images/police-icon.png') }}",
        iconSize: [35, 35], iconAnchor: [17, 35], popupAnchor: [0, -35]
    });
    const chargingStationIcon = new L.Icon({
        iconUrl: "{{ url_for('static', filename='images/charging-station-icon.png') }}",
        iconSize: [35, 35], iconAnchor: [17, 35], popupAnchor: [0, -35]
    });
    const petrolStationIcon = new L.Icon({
        iconUrl: "{{ url_for('static', filename='images/petrol-station-icon.png') }}",
        iconSize: [35, 35], iconAnchor: [17, 35], popupAnchor: [0, -35]
    });

    const allServicesData = JSON.parse('{{ services | tojson | safe }}');

    function drawServiceMarkers() {
    if (!allServicesData || !map) return;
    serviceMarkersLayer.clearLayers();

    const iconMap = {
        "hospitals": hospitalIcon,
        "police_stations": policeIcon,
        "charging_stations": chargingStationIcon,
        "petrol_stations": petrolStationIcon
    };

    for (const category in allServicesData) {
        const icon = iconMap[category] || L.Icon.Default();
        const services = allServicesData[category];

        services.forEach(service => {
            const serviceLatLng = L.latLng(service.lat, service.lng);
            // Give the marker a unique ID based on its properties for easy finding later
            const markerId = `${category}-${service.name.replace(/\s+/g, '-')}`;
            
            const marker = L.marker(serviceLatLng, { icon: icon, markerId: markerId });
            
            // Store data on the marker itself
            marker.serviceData = service; 
            
            const initialPopupContent = `
                <b>${service.name}</b><br>
                <button class="button-style btn-secondary" style="padding: 5px 10px; margin-top: 5px;" 
                        onclick="routeToService('${markerId}')">
                    Route to here
                </button>
            `;
            
            marker.bindPopup(initialPopupContent).addTo(serviceMarkersLayer);
        });
    }
    serviceMarkersLayer.addTo(map);
}

window.cancelPoiRoute = function() {
    if (poiRouteControl) {
        map.removeControl(poiRouteControl);
        poiRouteControl = null;
    }

    if (activePoiMarker) {
        const service = activePoiMarker.serviceData;
        const initialPopupContent = `
            <b>${service.name}</b><br>
            <button class="button-style btn-secondary" style="padding: 5px 10px; margin-top: 5px;" 
                    onclick="routeToService('${activePoiMarker.options.markerId}')">
                Route to here
            </button>
        `;
        activePoiMarker.setPopupContent(initialPopupContent);
        activePoiMarker = null;
    }
    map.closePopup(); 
}

window.routeToService = function(markerId) {
    if (activePoiMarker) {
        // This is a safety check. If a route is active, cancel it first.
        // It's better to find the old marker and update its popup too, but for now this is robust.
        cancelPoiRoute();
    }
    
    // Find the marker by its unique ID
    let marker = null;
    serviceMarkersLayer.eachLayer(layer => {
        if (layer.options.markerId === markerId) {
            marker = layer;
        }
    });

    if (!marker) {
        console.error("Could not find marker with ID:", markerId);
        return;
    }

    if (!userLiveMarker) {
        alert("Please set your location on the map first.");
        return;
    }
    
    activePoiMarker = marker; // Set the found marker as active
    const service = marker.serviceData;
    const userLatLng = userLiveMarker.getLatLng();
    const serviceLatLng = L.latLng(service.lat, service.lng);

    poiRouteControl = L.Routing.control({
        waypoints: [userLatLng, serviceLatLng],
        routeWhileDragging: false,
        show: true, addWaypoints: false,
        lineOptions: { styles: [{color: 'purple', opacity: 0.8, weight: 6}] },
        createMarker: function() { return null; }
    }).addTo(map);

    const activePopupContent = `
        <b>${service.name}</b>
        <p style="color: green; font-weight: bold; margin: 8px 0 5px 0;">Route is active.</p>
        <button class="button-style btn-cancel" style="padding: 5px 10px;" 
                onclick="cancelPoiRoute()">
            Cancel Route
        </button>
    `;
    marker.setPopupContent(activePopupContent).openPopup();
}
    function displayErrorOnMapContainer(message, errorObj) { const mapLoadingText = document.getElementById('mapLoadingText'); const mapDiv = document.getElementById('map'); if (mapLoadingText) mapLoadingText.style.display = 'none'; let detailedError = message; if (errorObj && errorObj.stack) { detailedError += "<br><pre style='font-size:0.8em; text-align:left; white-space:pre-wrap;word-break:break-all;'>" + errorObj.stack.substring(0,500) + "...</pre>"; } else if (errorObj) { detailedError += "<br><pre style='font-size:0.8em; text-align:left; white-space:pre-wrap;word-break:break-all;'>" + JSON.stringify(errorObj, null, 2) + "</pre>"; } if (mapDiv) { mapDiv.innerHTML = `<p style="padding:20px; text-align:center; color:red; font-weight:bold; font-size:1.1em; background-color: #ffe0e0; border: 1px solid red;">MAP INIT ERROR:<br>${detailedError}</p>`;} console.error("MAP ERROR:", message, errorObj); }
    function findClosestNodeKeyToLatLng(latlng, availableNodeCoords, routableGraph) { let closestKey = null; let minDist = Infinity; if (!availableNodeCoords || typeof availableNodeCoords !== 'object' || Object.keys(availableNodeCoords).length === 0) { console.warn("[findClosestNodeKeyToLatLng] availableNodeCoords data missing."); return null;} if (!routableGraph || typeof routableGraph !== 'object' || Object.keys(routableGraph).length === 0) { console.warn("[findClosestNodeKeyToLatLng] routableGraph data missing.");} for (const nodeKey in availableNodeCoords) { if (availableNodeCoords.hasOwnProperty(nodeKey)) { if (routableGraph && !routableGraph.hasOwnProperty(nodeKey)) continue; const nodeCoordArray = availableNodeCoords[nodeKey]; if(Array.isArray(nodeCoordArray) && nodeCoordArray.length === 2 && typeof nodeCoordArray[0] === 'number' && typeof nodeCoordArray[1] === 'number') { const nodeLatLng = L.latLng(nodeCoordArray[0], nodeCoordArray[1]); const dist = latlng.distanceTo(nodeLatLng); if (dist < minDist) { minDist = dist; closestKey = nodeKey; }} }} console.log("[findClosestNodeKeyToLatLng] Determined closest routable node:", closestKey); return closestKey; }
    function updateUserPreciseLocationAndSave(latlng) { const locMsgEl = document.getElementById('locationSetMessage'); const preciseLocDisplayEl = document.getElementById('currentUserPreciseLocation'); const subDisplayEl = document.getElementById('userClosestNodeSubDisplay'); const findBtn = document.getElementById('findNearestBtn'); locMsgEl.textContent = ""; if(preciseLocDisplayEl) preciseLocDisplayEl.textContent = `(${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)})`; if (userLiveMarker) { userLiveMarker.setLatLng(latlng).bindPopup(`Your Location: (${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)})`).openPopup(); } userClosestNodeKeyForDijkstra = findClosestNodeKeyToLatLng(latlng, coordsDataForDrivers, graphDataForDijkstra); if(subDisplayEl) subDisplayEl.style.display = 'none'; if (userClosestNodeKeyForDijkstra) { if(findBtn) { findBtn.disabled = false; findBtn.title = "Find Nearest Driver (Network Path)"; }} else { if(findBtn) { findBtn.disabled = true; findBtn.title = "Set location closer to a routable service point.";}} const latChanged = currentUserLatitude === null || Math.abs(currentUserLatitude - latlng.lat) > 1e-7; const lngChanged = currentUserLongitude === null || Math.abs(currentUserLongitude - latlng.lng) > 1e-7; if (latChanged || lngChanged) { fetch('/set-user-current-location', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({latitude:latlng.lat, longitude:latlng.lng})}).then(r=>r.json()).then(d=>{if(d.success){currentUserLatitude=d.latitude;currentUserLongitude=d.longitude;locMsgEl.textContent="Location Saved!";}else{locMsgEl.textContent="Could not save: "+(d.error||"");}setTimeout(()=>locMsgEl.textContent="",3000);}).catch(e=>{locMsgEl.textContent="Network Save Err.";setTimeout(()=>locMsgEl.textContent="",3000);});}else{locMsgEl.textContent="Location Confirmed.";setTimeout(()=>locMsgEl.textContent="",3000);} }
    function drawOrUpdateAllDriverMarkers() {
    console.log("[USER DASH] drawOrUpdateAllDriverMarkers called."); // Add log
    for (const emailKey in allDriverMapMarkers) { 
        if (allDriverMapMarkers[emailKey] && map.hasLayer(allDriverMapMarkers[emailKey])) {
            map.removeLayer(allDriverMapMarkers[emailKey]);
        }
    }
    allDriverMapMarkers = {};

    if (!allDriversDataForFinding || allDriversDataForFinding.length === 0) {
        console.warn("[UserDash] No driver data (allDriversDataForFinding) to draw markers.");
        return;
    }
    if (!coordsDataForDrivers || Object.keys(coordsDataForDrivers).length === 0) {
        console.warn("[UserDash] No coordinates data for drivers (coordsDataForDrivers).");
        return;
    }

    allDriversDataForFinding.forEach(driver => { 
        if (driver.node && coordsDataForDrivers.hasOwnProperty(driver.node)) {
            const driverCoordsArray = coordsDataForDrivers[driver.node]; 
            if (Array.isArray(driverCoordsArray) && driverCoordsArray.length === 2 && 
                typeof driverCoordsArray[0] === 'number' && typeof driverCoordsArray[1] === 'number') {
                
                const driverLatLng = L.latLng(driverCoordsArray[0], driverCoordsArray[1]); 
                let iconToUse = genericDriverIcon;
                let popupText = `Driver: ${driver.name}<br>Vehicle: ${driver.vehicle || 'N/A'}`; 
                let zIndexOffset = 0; 

            
                if (currentRideStatusFromServer && currentRideStatusFromServer.type === 'accepted' && currentRideStatusFromServer.driver_name === driver.name) {
                    iconToUse = enRouteDriverIcon;
                    popupText = `<b>Your Driver: ${driver.name} (En Route)</b><br>Vehicle: ${driver.vehicle || 'N/A'}`;
                    zIndexOffset = 1000;
                } else if (currentNearestDriverForConfirmation && currentNearestDriverForConfirmation.email === driver.email) {
                    iconToUse = previewDriverIcon;
                    popupText = `<b>Nearest: ${driver.name}</b><br>Vehicle: ${driver.vehicle || 'N/A'}<br>(Preview)`;
                    zIndexOffset = 500;
                }
              

                allDriverMapMarkers[driver.email] = L.marker(driverLatLng, { icon: iconToUse, zIndexOffset: zIndexOffset })
                    .addTo(map)
                    .bindPopup(popupText);
            } else {
                console.warn("UserDash: Invalid coords for driver node:", driver.node, "Coords:", driverCoordsArray);
            }
        } else {
            console.warn("UserDash: Driver", driver.name, "node '", driver.node, "' missing/invalid in coordsDataForDrivers.");
        }
    });
    console.log("[USER DASH] Finished drawing/updating driver markers."); // Add log
}
     function showChatBox(ride_data) {
        activeRideForChat = ride_data;
        document.getElementById('temporaryChatBox').style.display = 'flex';
        document.getElementById('chatMessages').innerHTML = ''; // Clear old messages
    }

    function hideChatBox() {
        activeRideForChat = null;
        document.getElementById('temporaryChatBox').style.display = 'none';
    }

    function sendChatMessage(event) {
        event.preventDefault();
        const input = document.getElementById('chatInput');
        const message = input.value.trim();
        if (message && activeRideForChat) {
            appendChatMessage(message, 'sent');
            // Make sure the ride_id property name matches what you get from the server
            // It could be 'id' or 'ride_id'
            const rideId = activeRideForChat.id || activeRideForChat.ride_id; 
            socket.emit('send_chat_message', {
                'message': message,
                'ride_id': rideId,
                'role': 'user' // This client's role is 'user'
            });
            input.value = '';
        }
    }

    function appendChatMessage(message, type) {
        const messagesList = document.getElementById('chatMessages');
        const li = document.createElement('li');
        li.className = type;
        li.textContent = message;
        messagesList.appendChild(li);
        messagesList.scrollTop = messagesList.scrollHeight;
    }
    function toggleChatWindow() {
    const chatBox = document.getElementById('temporaryChatBox');
    if (chatBox) {
        chatBox.classList.toggle('minimized');
    }
}
    // ===== END NEW CHAT FUNCTIONS =====

    document.addEventListener("DOMContentLoaded", function () 
    {

      const mapLoadingTextEl = document.getElementById('mapLoadingText');
      try {
          console.log("[USER DASH] DOMContentLoaded - BEGIN Map Initialization.");
          let mapInitialView = fallbackLatLng;
          let userMarkerInitialLatLng = fallbackLatLng;

          if (typeof coordsDataForDrivers !== 'object' || coordsDataForDrivers === null || Object.keys(coordsDataForDrivers).length === 0) {
             
              throw new Error("CRITICAL: Driver coordinates data (coordsDataForDrivers) is empty, null, or not an object. Cannot proceed with map initialization that relies on driver locations.");
          }
          if (typeof graphDataForDijkstra !== 'object' || graphDataForDijkstra === null) {
              console.warn("[USER DASH] Dijkstra graph data (graphDataForDijkstra) is invalid or not loaded. Network pathfinding will be impaired.");
              
          }

         
          if (currentUserLatitude !== null && currentUserLongitude !== null) {
              userMarkerInitialLatLng = L.latLng(currentUserLatitude, currentUserLongitude);
              mapInitialView = userMarkerInitialLatLng;
              console.log("[USER DASH] Initializing with user's current lat/lng:", userMarkerInitialLatLng.toString());
              userClosestNodeKeyForDijkstra = findClosestNodeKeyToLatLng(userMarkerInitialLatLng, coordsDataForDrivers, graphDataForDijkstra);
          } else if (currentRideStatusFromServer && currentRideStatusFromServer.type === 'accepted' &&
                     currentRideStatusFromServer.user_latitude_for_route !== null &&
                     currentRideStatusFromServer.user_longitude_for_route !== null) {
              userMarkerInitialLatLng = L.latLng(currentRideStatusFromServer.user_latitude_for_route, currentRideStatusFromServer.user_longitude_for_route);
              mapInitialView = userMarkerInitialLatLng;
              const preciseLocDisp = document.getElementById('currentUserPreciseLocation');
              if(preciseLocDisp) preciseLocDisp.textContent = `(${userMarkerInitialLatLng.lat.toFixed(6)}, ${userMarkerInitialLatLng.lng.toFixed(6)})`;
              currentUserLatitude = userMarkerInitialLatLng.lat; currentUserLongitude = userMarkerInitialLatLng.lng;
              userClosestNodeKeyForDijkstra = findClosestNodeKeyToLatLng(userMarkerInitialLatLng, coordsDataForDrivers, graphDataForDijkstra);
              console.log("[USER DASH] Initializing with accepted ride's user location:", userMarkerInitialLatLng.toString());
          } else {
              console.log("[USER DASH] Falling back to default LatLng for initial marker and view.");
          }

         
          const findBtn = document.getElementById('findNearestBtn');
          const subDisplayEl = document.getElementById('userClosestNodeSubDisplay');
          if(subDisplayEl) subDisplayEl.style.display = 'none'; // Keep hidden as per earlier request

          if (userClosestNodeKeyForDijkstra && graphDataForDijkstra && Object.keys(graphDataForDijkstra).length > 0) {
              if(findBtn && (currentUserLatitude !== null && currentUserLongitude !== null) ) { findBtn.disabled = false; findBtn.title = "Find Nearest Driver (Network Path)"; }
              else if(findBtn) { findBtn.disabled = true; findBtn.title = "Click map to set your location first.";}
          } else { // No closest node or no graph for Dijkstra
              if(findBtn) {
                  findBtn.disabled = true;
                  findBtn.title = graphDataForDijkstra && Object.keys(graphDataForDijkstra).length > 0 ?
                                  "Set location closer to a routable service point." :
                                  "Network routing data unavailable.";
              }
          }
          if (currentUserLatitude === null || currentUserLongitude === null) { 
               if(findBtn) { findBtn.disabled = true; findBtn.title = "Click the map to set your location first."; }
          }

          const mapDiv = document.getElementById('map');
          if (!mapDiv) throw new Error("Map container element with ID 'map' not found in the DOM.");

          if(mapLoadingTextEl) mapLoadingTextEl.remove(); 

          console.log("[USER DASH] Attempting to initialize Leaflet map. Final mapInitialView:", mapInitialView.toString(), "Zoom: 13");
          if (!(mapInitialView instanceof L.LatLng) || isNaN(mapInitialView.lat) || isNaN(mapInitialView.lng) ) {
              console.error("[USER DASH] CRITICAL: mapInitialView is invalid before L.map(). Forcing fallback.", mapInitialView);
              mapInitialView = fallbackLatLng;
          }

           map = L.map('map').setView(mapInitialView, 14);
          console.log("[USER DASH] Leaflet map object IS CREATED:", map);

          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 18, attribution: '© OSM' })
              .on('tileerror', function(e){ console.error("[USER DASH] TileLayer Error:", e); displayErrorOnMapContainer("Map tiles failed to load. Check internet connection or tile server configuration."); })
              .addTo(map);
          console.log("[USER DASH] TileLayer added to map.");
           
          

          if (!(userMarkerInitialLatLng instanceof L.LatLng) || isNaN(userMarkerInitialLatLng.lat) || isNaN(userMarkerInitialLatLng.lng)) {
              console.warn("[USER DASH] userMarkerInitialLatLng invalid, using fallback for user marker.", userMarkerInitialLatLng);
              userMarkerInitialLatLng = fallbackLatLng;
          }
          console.log("[USER DASH] Adding userLiveMarker at:", userMarkerInitialLatLng.toString());
          userLiveMarker = L.marker(userMarkerInitialLatLng, { icon: userIcon, draggable: true })
            .addTo(map).bindPopup(currentUserLatitude !== null ? `Your Location: (${currentUserLatitude.toFixed(6)}, ${currentUserLongitude.toFixed(6)})` : "Click map to set your location").openPopup();
          userLiveMarker.on('dragend',function(e){ updateUserPreciseLocationAndSave(e.target.getLatLng()); });
          map.on("click", function (e) { updateUserPreciseLocationAndSave(e.latlng); });
          console.log("[USER DASH] userLiveMarker and event listeners added.");

          drawOrUpdateAllDriverMarkers();
          console.log("[USER DASH] All driver markers drawn/updated.");
          drawServiceMarkers();
          
          if (currentRideStatusFromServer && currentRideStatusFromServer.type === 'accepted' &&
              currentRideStatusFromServer.driver_node && coordsDataForDrivers[currentRideStatusFromServer.driver_node] &&
              currentRideStatusFromServer.user_latitude_for_route !== null &&
              currentRideStatusFromServer.user_longitude_for_route !== null) 
              {
              console.log("[USER DASH] Accepted ride detected. Attempting to draw route to driver.");
              const driverNodeCoords = coordsDataForDrivers[currentRideStatusFromServer.driver_node];
              const driverLatLng = L.latLng(driverNodeCoords[0], driverNodeCoords[1]);
              const userLatLngForRoute = L.latLng(currentRideStatusFromServer.user_latitude_for_route, currentRideStatusFromServer.user_longitude_for_route);
              if (userLiveMarker) userLiveMarker.setLatLng(userLatLngForRoute);
              drawMainAcceptedRoute(userLatLngForRoute, driverLatLng);
              console.log("[USER DASH] Accepted ride route drawing attempted.");
              showChatBox({ ride_id: currentRideStatusFromServer.ride_id });
          } else if (currentRideStatusFromServer && currentRideStatusFromServer.type === 'accepted') {
              console.warn("[USER DASH] Accepted ride exists, but required node/lat-lng data for route is incomplete/invalid.", currentRideStatusFromServer);
          }

          console.log("[USER DASH] Attempting map.invalidateSize() call.");
          setTimeout(() => {
              if (map && typeof map.invalidateSize === 'function') {
                  console.log("[USER DASH] Forcing map.invalidateSize()");
                  map.invalidateSize(true);
                  console.log("[USER DASH] map.invalidateSize() called.");
              } else {
                  console.error("[USER DASH] Map object not available or invalidateSize is not a function for timeout call.");
              }
          }, 600); 
          console.log("[USER DASH] DOMContentLoaded finished successfully.");

      } catch (error) {
          console.error("CRITICAL ERROR during User Dashboard map initialization process:", error);
          displayErrorOnMapContainer(error.message, error); // Pass the error object for stack trace
      }
      try {
            console.log("[USER DASH] Attempting Socket.IO connection...");
            socket = io.connect(location.protocol + '//' + document.domain + ':' + location.port);

            socket.on('connect', function() 
            {
                console.log('[USER DASH] Socket.IO Connected! SID:', socket.id);
                const userEmail = "{{ user.email if user and user.email else '' }}"; // Get email from Flask context
                if (userEmail) {
                    console.log("[USER DASH] Emitting 'join' event for email:", userEmail);
                    socket.emit('join', {email: userEmail});
                } else {
                    console.warn("[USER DASH] User email not available in template for joining room.");
                }
            });

            socket.on('new_suggestion', function(data) {
    console.log('[USER DASH] Received new_suggestion:', data);
    alert(data.message); // Notify the user

    // Update the status display on the page
    const notificationsDiv = document.getElementById('notifications');
    if (notificationsDiv) {
        notificationsDiv.innerHTML = `
            <h4>Current Ride Status:</h4>
            <p class="status-pending">
                ${data.message}
            </p>`;
    }
});

// Listen for the final timeout if no other drivers are found
socket.on('ride_timeout_no_drivers', function(data) {
    console.log('[USER DASH] Received ride_timeout_no_drivers:', data);
    alert(data.message);

    const notificationsDiv = document.getElementById('notifications');
    if (notificationsDiv) {
        notificationsDiv.innerHTML = `
            <h4>Current Ride Status:</h4>
            <p class="status-rejected">
                ${data.message}
            </p>
            <button onclick="findNearestAndShowPreview(true)" class="btn-secondary" style="margin-top: 10px;">
                Try Finding a Driver Again
            </button>`;
    }
    // Re-enable the main find button
    document.getElementById('findNearestBtn').disabled = false;
});
            socket.on('connect_error', (error) => {
                console.error('[USER DASH] Socket.IO Connection Error:', error);
                // Optionally display a user-friendly message on the page
            });
            socket.on('disconnect', (reason) => {
               console.log('[USER DASH] Socket.IO Disconnected:', reason);
            });

            // Listen for ride status updates from the server
            socket.on('ride_accepted', function(data) {
    console.log('[USER DASH] Ride accepted, updating UI dynamically:', data);
    excludedDriverEmails = []; // Reset the exclusion list on a successful ride
    alert(data.message);

    // Step 1: Update the status panel to show a success message
    const notificationsDiv = document.getElementById('notifications');
    if (notificationsDiv) {
        notificationsDiv.innerHTML = `<h4>Current Ride Status:</h4><p class="status-accepted">${data.message}</p>`;
    }
    
    // Step 2: Hide the driver search UI and disable the main find button
    document.getElementById("nearestDriverInfo").style.display = 'none';
    document.getElementById('findNearestBtn').disabled = true;

    // Step 3: Draw the route, update the driver icon, and show the chat box
    if (data.driver_node && coordsDataForDrivers[data.driver_node] && data.user_latitude_for_route != null) {
        const driverLatLng = L.latLng(coordsDataForDrivers[data.driver_node][0], coordsDataForDrivers[data.driver_node][1]);
        const userLatLng = L.latLng(data.user_latitude_for_route, data.user_longitude_for_route);

        if (userLiveMarker) {
            userLiveMarker.setLatLng(userLatLng);
        }
        drawMainAcceptedRoute(userLatLng, driverLatLng);
        
        // Update the global state so `drawOrUpdateAllDriverMarkers` knows which driver is en-route
        currentRideStatusFromServer = { type: 'accepted', driver_name: data.driver_name, ride_id: data.ride_id };
        drawOrUpdateAllDriverMarkers(); // This will change the driver's icon to the blue "en-route" one
        
        showChatBox(data); // Show the chat
    }
});

            socket.on('ride_rejected', function(data) {
    console.log('[USER DASH] Ride rejected, updating UI dynamically:', data);
    alert(data.message);

    
    if (data.driver_email && !excludedDriverEmails.includes(data.driver_email)) {
        excludedDriverEmails.push(data.driver_email);
        console.log("Updated exclusion list:", excludedDriverEmails);
    }

    
    const notificationsDiv = document.getElementById('notifications');
    if (notificationsDiv) {
        notificationsDiv.innerHTML = `
            <h4>Current Ride Status:</h4>
            <p class="status-rejected">${data.message}</p>
            <button onclick="findNearestAndShowPreview(false)" class="btn-secondary" style="margin-top: 10px;">Find Another Driver</button>
        `;
    }
    
    
    document.getElementById('findNearestBtn').disabled = false;
    
    
    cancelDriverSelectionAndClearPreview();
});
            socket.on('ride_completed', function(data) {
    console.log('[USER DASH] Ride completed, resetting UI.');

    excludedDriverEmails = []; // Reset the exclusion list
    alert(data.message);
    hideChatBox();

    // Reset the UI elements to their initial state
    const notificationsDiv = document.getElementById('notifications');
    notificationsDiv.innerHTML = '<h4>Current Ride Status:</h4><p>Your previous ride was completed. Click "Find Nearest Driver" to start a new request.</p>';
    document.getElementById('findNearestBtn').disabled = false;
    
    // Clear map elements
    clearMainAcceptedRoute();
    currentRideStatusFromServer = null;
    drawOrUpdateAllDriverMarkers(); // This will reset all driver icons to red
});
                 
socket.on('receive_chat_message', function(data) 
            {
            console.log("Received chat message:", data);
            appendChatMessage(data.message, 'received');
            });

            socket.on('status_update', function(data) { // For join confirmation
                 console.log('[USER DASH] Received status_update:', data.msg);
            });

        } catch (e) {
            console.error("[USER DASH] Error initializing Socket.IO:", e);
            // Optionally display an error message on the page
        }
        // --- END SOCKET.IO Connection ---
    });


    function clearMainAcceptedRoute() { if (mainAcceptedRouteControl) { map.removeControl(mainAcceptedRouteControl); mainAcceptedRouteControl = null; }}
    function clearPreviewDijkstraPath() { if (previewDijkstraPathLayer) { map.removeLayer(previewDijkstraPathLayer); previewDijkstraPathLayer = null; } if (currentNearestDriverForConfirmation && allDriverMapMarkers[currentNearestDriverForConfirmation.email]) { let iconR = genericDriverIcon; if (currentRideStatusFromServer && currentRideStatusFromServer.type === 'accepted' && currentRideStatusFromServer.driver_name === currentNearestDriverForConfirmation.name) iconR = enRouteDriverIcon; try{allDriverMapMarkers[currentNearestDriverForConfirmation.email].setIcon(iconR).setZIndexOffset(0);}catch(e){/*ignore if marker removed*/} } }
    function drawMainAcceptedRoute(usrLtLng, drvLtLng) { clearMainAcceptedRoute(); console.log("[UserDash] Drawing MAIN accepted route between User:", usrLtLng.toString(), "and Driver:", drvLtLng.toString()); mainAcceptedRouteControl = L.Routing.control({ waypoints: [usrLtLng, drvLtLng], routeWhileDragging: false, show: false, addWaypoints: false, lineOptions: { styles: [{color: 'blue', opacity: 0.9, weight: 6}] }, createMarker: ()=>null }).addTo(map); map.fitBounds(L.latLngBounds([usrLtLng, drvLtLng]), {padding: [50,50]}); }

    
 window.findNearestAndShowPreview = function (isNewSearch) {
     if (isNewSearch) {
        console.log("Starting a new search, clearing exclusion list.");
        excludedDriverEmails = [];
    }
    if (currentUserLatitude === null || currentUserLongitude === null) {
        alert("Please set your location on the map first.");
        return;
    }
    if (graphDataForDijkstra && Object.keys(graphDataForDijkstra).length > 0 && !userClosestNodeKeyForDijkstra) {
        alert("Cannot determine nearest service point for network routing. Try clicking the map again.");
        return;
    }
    const findBtn = document.getElementById('findNearestBtn');
    findBtn.disabled = true;
    clearPreviewDijkstraPath();
    const infoDiv = document.getElementById("nearestDriverInfo");
    infoDiv.innerHTML = `<div class="spinner-loader" style="display: block; margin-bottom: 5px;"></div><p>Finding nearest driver...</p>`;
    infoDiv.style.display = 'block';
    currentNearestDriverForConfirmation = null;
    const selectedVehicleType = document.getElementById('vehicleTypeSelect').value;

    // ==========================================================
    // ===== START OF REPLACEMENT LOGIC =====
    // ==========================================================
    
    // 1. Create the base payload object
    const payload = {
        user_closest_node: userClosestNodeKeyForDijkstra,
        vehicle_type: selectedVehicleType,
        exclude_drivers: excludedDriverEmails // 2. Add the entire array of excluded emails
    };

    console.log("Searching for nearest driver with payload:", payload);

    // ==========================================================
    // ===== END OF REPLACEMENT LOGIC =====
    // ==========================================================

    fetch('/find-nearest-driver-dijkstra', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload) // 3. Send the payload with the array
        })
        .then(r => {
            if (!r.ok) return r.text().then(text => {
                throw new Error("Server error: " + r.status + " " + text.substring(0, 100))
            });
            return r.json();
        })
        .then(d => {
            if (d.success && d.nearest_driver) {
                currentNearestDriverForConfirmation = d.nearest_driver;
                drawOrUpdateAllDriverMarkers();
                let vL = selectedVehicleType ? selectedVehicleType : 'Vehicle';
                if (selectedVehicleType && d.nearest_driver.vehicle && !d.nearest_driver.vehicle.toLowerCase().includes(selectedVehicleType.toLowerCase())) vL = d.nearest_driver.vehicle || 'Vehicle';
                infoDiv.innerHTML = `<p><strong>Nearest ${vL}:</strong> ${d.nearest_driver.name} (Node ${d.nearest_driver.node})<br>Vehicle: ${d.nearest_driver.vehicle||'N/A'}<br>Path Dist: ${d.nearest_driver.graph_distance} units</p><button class="btn-confirm" onclick="confirmRequestAndClearPreview()">Confirm</button> <button class="btn-cancel" onclick="cancelDriverSelectionAndClearPreview()">Cancel</button>`;
            } else {
                infoDiv.innerHTML = `<p>${d.message||`No reachable ${selectedVehicleType||'drivers'} found.`}</p>`;
                // Clear the exclusion list if no drivers are found at all, allowing the user to start a fresh search
                if (!d.nearest_driver) {
                    excludedDriverEmails = [];
                    console.log("No drivers found. Exclusion list has been reset.");
                }
                drawOrUpdateAllDriverMarkers();
            }
        }).catch(e => {
            console.error("Dijkstra fetch err:", e);
            infoDiv.innerHTML = `<p style="color:red;">Error: ${e.message}</p>`;
            drawOrUpdateAllDriverMarkers();
        }).finally(() => {
            if (findBtn) findBtn.disabled = false;
        });
};


// And ensure your 'ride_accepted' and 'ride_completed' listeners clear the list


    window.cancelDriverSelectionAndClearPreview = function() {
    clearPreviewDijkstraPath();
    currentNearestDriverForConfirmation = null;
    drawOrUpdateAllDriverMarkers(); // Redraws markers to remove the "preview" icon
    document.getElementById("nearestDriverInfo").style.display = 'none';

    // Re-enable the main "Find Nearest" button
    const findBtn = document.getElementById('findNearestBtn');
    if (findBtn) {
        // Enable the button only if the user has set their location
        findBtn.disabled = !(currentUserLatitude !== null && currentUserLongitude !== null);
    }
};

window.confirmRequestAndClearPreview = function() {
    if (!currentNearestDriverForConfirmation || currentUserLatitude === null) {
        alert("Driver selection or your location is not properly set.");
        cancelDriverSelectionAndClearPreview();
        return;
    }

    const infoDiv = document.getElementById("nearestDriverInfo");
    infoDiv.innerHTML = `<p>Sending request to ${currentNearestDriverForConfirmation.name}... Please wait.</p>`;
    
    // Disable the buttons in the info div to prevent double-clicks
    infoDiv.querySelectorAll('button').forEach(btn => btn.disabled = true);
    
    const driverEmailToSend = currentNearestDriverForConfirmation.email;
    
    // Clear visual previews from the map
    clearPreviewDijkstraPath();
    currentNearestDriverForConfirmation = null;
    drawOrUpdateAllDriverMarkers();
    clearMainAcceptedRoute();

    fetch('/request-ride', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ driver_email: driverEmailToSend })
    })
    .then(r => {
        if (!r.ok) return r.text().then(t => { throw new Error("Server error: " + r.status + " " + t.substring(0, 100)) });
        return r.json();
    })
    .then(d => {
        if (!d.success) {
            throw new Error(d.message || "Request failed.");
        }
        
        // --- DYNAMIC UI UPDATE ON SUCCESS ---
        // 1. Hide the driver selection/info box
        infoDiv.style.display = 'none';
        
        // 2. Update the main status notification panel
        const notificationsDiv = document.getElementById('notifications');
        if (notificationsDiv) {
    notificationsDiv.innerHTML = `
        <h4>Current Ride Status:</h4>
        <p class="status-pending">
            Request sent. Waiting for driver to respond...
        </p>
        <small style="color: #555;">(If there is no response within 1 minutes, we will automatically search for the next nearest driver for you.)</small>
    `;
}
        
        // 3. Disable the main "Find Nearest Driver" button until the request is resolved
        const findBtn = document.getElementById('findNearestBtn');
        if (findBtn) {
            findBtn.disabled = true;
        }

    })
    .catch(e => {
        console.error('Ride request error:', e);
        // On error, show a try again button
        infoDiv.innerHTML = `
            <p style="color:red;">Error: ${e.message}</p>
            <button class="btn-secondary" onclick="findNearestAndShowPreview()">Try Again</button>
        `;
        document.getElementById('findNearestBtn').disabled = false;
    });
};

</script>
{% endblock %}